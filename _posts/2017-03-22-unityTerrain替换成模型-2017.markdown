---
layout:     post
title:      "unityTerrain替换成模型方法"
subtitle:   " \"unity Terrain 模型\""
date:       2017-03-22
author:     "LOFOXO"
header-img: "img/terrain-bg-2017.jpg"
catalog: true
tags:
    - Scenes
---

> “unityTerrain替换成模型方法”

前言
--
使用unity制作场景的过程中，Terrain是性能优化的一大问题，对于Terrain的优化最好方式是能够
直接将其转化为模型文件，同时又不会影响其在unity编辑好的效果。在这之前，一直没有比较好的方
式去解决这个问题，最近在mc项目的优化过程中偶然发现一种方法可以较为完美地解决这个问题。

**注：本方法对于Terrain的贴图数量有限制，要求在三张或三张以下（rgb），当然大神可以通过修
改shader的方式去将图片的alpha通道加入其中，这样可以用到四张贴图**

解决方案
----

将unity编辑好的Terrain转化为模型的思路主要分为两个部分：

 1. 将Terrain系统的模型转化为max可编辑的模型文件obj
 2. 将Terrain编辑后的SplatAlpha文件导出成ps可以编辑的图片文件


模型文件的导出
--------
在mc项目主城中创建的一个Terrain进行编辑完成后如图

![](/blog.github.io/img/post-terrain/post-terrain-01.png)
这里Terrain主要用到了三张贴图，一张草地的，一张海边缘的沙子，一张道路的土。

在优化项目的过程中偶然发现了一个可以将Terrain导出成obj的脚本，瞬间联想到可以将obj导入max
中进行减面转换格式等操作，同时，可以将Terrain编辑好的那张颜色贴图导出作为各个贴图的混合贴
图。
Terrain导出成obj的脚本如下
```
using UnityEngine;
using UnityEditor;
using System;
using System.Collections;
using System.IO;
using System.Text;

enum SaveFormat { Triangles, Quads }
enum SaveResolution { Full = 0, Half, Quarter, Eighth, Sixteenth }

class ExportTerrain : EditorWindow
{
    SaveFormat saveFormat = SaveFormat.Triangles;
    SaveResolution saveResolution = SaveResolution.Half;

    static TerrainData terrain;
    static Vector3 terrainPos;

    int tCount;
    int counter;
    int totalCount;
    int progressUpdateInterval = 10000;

    [MenuItem("Terrain/Export To Obj...")]
    static void Init()
    {
        terrain = null;
        Terrain terrainObject = Selection.activeObject as Terrain;
        if (!terrainObject)
        {
            terrainObject = Terrain.activeTerrain;
        }
        if (terrainObject)
        {
            terrain = terrainObject.terrainData;
            terrainPos = terrainObject.transform.position;
        }

        EditorWindow.GetWindow<ExportTerrain>().Show();
    }

    void OnGUI()
    {
        if (!terrain)
        {
            GUILayout.Label("No terrain found");
            if (GUILayout.Button("Cancel"))
            {
                EditorWindow.GetWindow<ExportTerrain>().Close();
            }
            return;
        }
        saveFormat = (SaveFormat)EditorGUILayout.EnumPopup("Export Format", saveFormat);

        saveResolution = (SaveResolution)EditorGUILayout.EnumPopup("Resolution", saveResolution);

        if (GUILayout.Button("Export"))
        {
            Export();
        }
    }

    void Export()
    {
        string fileName = EditorUtility.SaveFilePanel("Export .obj file", "", "Terrain", "obj");
        int w = terrain.heightmapWidth;
        int h = terrain.heightmapHeight;
        Vector3 meshScale = terrain.size;
        int tRes = (int)Mathf.Pow(2, (int)saveResolution);
        meshScale = new Vector3(meshScale.x / (w - 1) * tRes, meshScale.y, meshScale.z / (h - 1) * tRes);
        Vector2 uvScale = new Vector2(1.0f / (w - 1), 1.0f / (h - 1));
        float[,] tData = terrain.GetHeights(0, 0, w, h);

        w = (w - 1) / tRes + 1;
        h = (h - 1) / tRes + 1;
        Vector3[] tVertices = new Vector3[w * h];
        Vector2[] tUV = new Vector2[w * h];

        int[] tPolys;

        if (saveFormat == SaveFormat.Triangles)
        {
            tPolys = new int[(w - 1) * (h - 1) * 6];
        }
        else
        {
            tPolys = new int[(w - 1) * (h - 1) * 4];
        }

        // Build vertices and UVs
        for (int y = 0; y < h; y++)
        {
            for (int x = 0; x < w; x++)
            {
                tVertices[y * w + x] = Vector3.Scale(meshScale, new Vector3(-y, tData[x * tRes, y * tRes], x)) + terrainPos;
                tUV[y * w + x] = Vector2.Scale(new Vector2(x * tRes, y * tRes), uvScale);
            }
        }

        int index = 0;
        if (saveFormat == SaveFormat.Triangles)
        {
            // Build triangle indices: 3 indices into vertex array for each triangle
            for (int y = 0; y < h - 1; y++)
            {
                for (int x = 0; x < w - 1; x++)
                {
                    // For each grid cell output two triangles
                    tPolys[index++] = (y * w) + x;
                    tPolys[index++] = ((y + 1) * w) + x;
                    tPolys[index++] = (y * w) + x + 1;

                    tPolys[index++] = ((y + 1) * w) + x;
                    tPolys[index++] = ((y + 1) * w) + x + 1;
                    tPolys[index++] = (y * w) + x + 1;
                }
            }
        }
        else
        {
            // Build quad indices: 4 indices into vertex array for each quad
            for (int y = 0; y < h - 1; y++)
            {
                for (int x = 0; x < w - 1; x++)
                {
                    // For each grid cell output one quad
                    tPolys[index++] = (y * w) + x;
                    tPolys[index++] = ((y + 1) * w) + x;
                    tPolys[index++] = ((y + 1) * w) + x + 1;
                    tPolys[index++] = (y * w) + x + 1;
                }
            }
        }

        // Export to .obj
        StreamWriter sw = new StreamWriter(fileName);
        try
        {

            sw.WriteLine("# Unity terrain OBJ File");

            // Write vertices
            System.Threading.Thread.CurrentThread.CurrentCulture = new System.Globalization.CultureInfo("en-US");
            counter = tCount = 0;
            totalCount = (tVertices.Length * 2 + (saveFormat == SaveFormat.Triangles ? tPolys.Length / 3 : tPolys.Length / 4)) / progressUpdateInterval;
            for (int i = 0; i < tVertices.Length; i++)
            {
                UpdateProgress();
                StringBuilder sb = new StringBuilder("v ", 20);
                // StringBuilder stuff is done this way because it's faster than using the "{0} {1} {2}"etc. format
                // Which is important when you're exporting huge terrains.
                sb.Append(tVertices[i].x.ToString()).Append(" ").
                   Append(tVertices[i].y.ToString()).Append(" ").
                   Append(tVertices[i].z.ToString());
                sw.WriteLine(sb);
            }
            // Write UVs
            for (int i = 0; i < tUV.Length; i++)
            {
                UpdateProgress();
                StringBuilder sb = new StringBuilder("vt ", 22);
                sb.Append(tUV[i].x.ToString()).Append(" ").
                   Append(tUV[i].y.ToString());
                sw.WriteLine(sb);
            }
            if (saveFormat == SaveFormat.Triangles)
            {
                // Write triangles
                for (int i = 0; i < tPolys.Length; i += 3)
                {
                    UpdateProgress();
                    StringBuilder sb = new StringBuilder("f ", 43);
                    sb.Append(tPolys[i] + 1).Append("/").Append(tPolys[i] + 1).Append(" ").
                       Append(tPolys[i + 1] + 1).Append("/").Append(tPolys[i + 1] + 1).Append(" ").
                       Append(tPolys[i + 2] + 1).Append("/").Append(tPolys[i + 2] + 1);
                    sw.WriteLine(sb);
                }
            }
            else
            {
                // Write quads
                for (int i = 0; i < tPolys.Length; i += 4)
                {
                    UpdateProgress();
                    StringBuilder sb = new StringBuilder("f ", 57);
                    sb.Append(tPolys[i] + 1).Append("/").Append(tPolys[i] + 1).Append(" ").
                       Append(tPolys[i + 1] + 1).Append("/").Append(tPolys[i + 1] + 1).Append(" ").
                       Append(tPolys[i + 2] + 1).Append("/").Append(tPolys[i + 2] + 1).Append(" ").
                       Append(tPolys[i + 3] + 1).Append("/").Append(tPolys[i + 3] + 1);
                    sw.WriteLine(sb);
                }
            }
        }
        catch (Exception err)
        {
            Debug.Log("Error saving file: " + err.Message);
        }
        sw.Close();

        terrain = null;
        EditorUtility.DisplayProgressBar("Saving file to disc.", "This might take a while...", 1f);
        EditorWindow.GetWindow<ExportTerrain>().Close();
        EditorUtility.ClearProgressBar();
    }

    void UpdateProgress()
    {
        if (counter++ == progressUpdateInterval)
        {
            counter = 0;
            EditorUtility.DisplayProgressBar("Saving...", "", Mathf.InverseLerp(0, totalCount, ++tCount));
        }
    }
}

```
**记得将脚本放在Editor文件夹下，这样在unity的上方会出现一个Terrain的按钮，点开进行操作**

模型的处理
--------
接下来主要要做的就是将obj的模型文件导入到max中，将其根据需要进行减面，最后导出成fbx文件导
入到unity中进行使用

如图所示，这是导出的obj文件导入到max的相关情况，可以看出面数上超高了

![](/blog.github.io/img/post-terrain/post-terrain-02.jpg)

这里推荐大家一个简单省事的建模操作，利用max自带的Multires自动减面修改器进行修改。根据自己
的需求进行适当的减面。这里讲原来十几万面的模型减到了两千多个三角面，完全符合了手游的要求

如下图所示为减面后的模型：
![](/blog.github.io/img/post-terrain/post-terrain-03.jpg)

将减面后的模型文件导入到unity中，和原来的Terrain进行大小上的调整。

混合贴图的制作
--------
为了和原来Terrain编辑好的效果一模一样，我们需要将Terrain文件内的混合贴图导出，以便我们的
使用
如下图所示，SplatAlpha0就是我们地形编辑好的混合贴图文件，我们用一个在网络上收集来的脚本进
行导出。
![](/blog.github.io/img/post-terrain/post-terrain-05.jpg)
**注：该脚本是之前为了能够在ps上编辑Terrain贴图而设计的，功能强大，万能的网友们的分享精神
真是太棒了。在解决这个问题时瞬间想到这个制作混合贴图的方法。**
